ISA: x86_64

;;;; PRELIMINARY COMMENTARY
;; NOTE: Search `;;;;` at beginning of line for section annotations

;; Comment

;; At top of every isel file is metadata. One definition per line. Ends
;; with an empty line, and that is where the match definitions may
;; begin.

;; Each definition begins with the keyword `match`.
;; Following `match` comes one or more instruction specifications,
;; constrained to general MIR opcodes.
;; An instruction specification is constructed like so:
;;   `<opcode> <identifier> "(" { <operand-type> <identifier> [ "=" <expression> ] [ "," ] } ")" [ "," ]`
;; After the instruction specifications comes the emitted instructions,
;; after the keyword `emit`. This is a block (wrapped in curly brackets)
;; of instruction specifications that are not constrained in any way.

;; Commas are optional.
;; Identifiers ARE case sensitive.

;; For now, just use C identifiers for opcodes

;; Operand Kind
;; Register == REG  == MIR_OP_REGISTER
;; Immediate == IMM == MIR_OP_IMMEDIATE
;; Block            == MIR_OP_BLOCK
;; Function == FUN  == MIR_OP_FUNCTION
;; Local            == MIR_OP_LOCAL_REF
;; Static           == MIR_OP_STATIC_REF

;; Every isel file that is parsed will start with the general MIR
;; opcodes defined, as well as some other things like the CompareType
;; enum.
;; The ISA should add definitions for its opcodes.

;; NOTE: Input MIR instructions are lowered from IR (general MIR), so
;; each one technically has it's own "result" virtual register that may
;; be accesed by using the name of the matched instruction. YOU CANNOT
;; USE THE RESULT REGISTER OF A LOWERED INSTRUCTION!

;; TODO: Special Operands:
;; ZERO  == MIR_OP_IMMEDIATE with value of 0
;; VREG  == MIR_OP_REGISTER with new virtual register value (TODO: is this actually needed/allowed?)

;; TODO: Figure out how to handle opcodes that should never show up here
;; MIR_PHI
;; MIR_REGISTER
;; MIR_PARAMETER
;; MIR_LIT_INTEGER
;; MIR_LIT_STRING

;; TODO: Write patterns for these opcodes
;; MIR_STORE
;; MIR_STATIC_REFERENCE
;; MIR_FUNCTION_REFERENCE
;; MIR_TRUNCATE (emit different things based on result register size or smth)
;; MIR_BITCAST (emit nothing)
;; MIR_CALL... do it in code because it's complicated? *Where* in code?

match MIR_IMMEDIATE i1(Immediate imm)
emit MX64_MOV(imm, i1)

match MIR_NOT i1(Register r)
emit {
  MX64_NOT(r)
  MX64_MOV(r, i1)
}

match MIR_ZERO_EXTEND i1(Register r)
emit MX64_MOVZX(r, i1)
match MIR_SIGN_EXTEND i1(Register r)
emit MX64_MOVSX(r, i1)

match MIR_AND i1(Register value, Immediate mask)
emit {
  MX64_AND(mask, value)
  MX64_MOV(value, i1)
}

match MIR_ALLOCA i1(Local object)
emit MX64_LEA(Register bp = rbp, object, i1)

match MIR_COPY i1(Register src)
emit MX64_MOV(src, i1)

;;;; CONTROL FLOW

match MIR_BRANCH br(Block b)
emit MX64_JMP(b)

match MIR_BRANCH_CONDITIONAL cond_br(Register cond, Block then, Block otherwise)
emit {
  MX64_TEST(cond, cond)
  MX64_JCC(Immediate jump_type = JUMP_TYPE_Z, otherwise)
  MX64_JMP(then)
}

match MIR_RETURN ret()
emit MX64_RET()
match MIR_RETURN ret(Register reg)
emit {
  MX64_MOV(reg, ret)
  MX64_RET()
}
match MIR_RETURN ret(Immediate imm)
emit {
  MX64_MOV(imm, ret)
  MX64_RET()
}

;;;; ARITHMETIC

match
MIR_ADD i1(Immediate lhs, Immediate rhs)
emit {
  MX64_MOV(rhs, i1)
  MX64_ADD(lhs, i1)
}
match
MIR_ADD i1(Register lhs, Register rhs)
emit {
  MX64_ADD(rhs, lhs)
  MX64_MOV(lhs, i1)
}
match
MIR_ADD i1(Register reg, Immediate imm)
emit {
  MX64_ADD(imm, reg)
  MX64_MOV(reg, i1)
}
match
MIR_ADD i1(Immediate imm, Register reg)
emit {
  MX64_ADD(imm, reg)
  MX64_MOV(reg, i1)
}

match
MIR_MUL i1(Immediate lhs, Immediate rhs)
emit {
  MX64_MOV(lhs, i1)
  MX64_IMUL(rhs, i1)
}
match
MIR_MUL i1(Register lhs, Register rhs)
emit {
  MX64_IMUL(rhs, lhs)
  MX64_MOV(lhs, i1)
}
match
MIR_MUL i1(Register reg, Immediate imm)
emit {
  MX64_IMUL(imm, reg)
  MX64_MOV(reg, i1)
}
match
MIR_MUL i1(Immediate imm, Register reg)
emit {
  MX64_IMUL(imm, reg)
  MX64_MOV(reg, i1)
}

match
MIR_SUB i1(Immediate lhs, Immediate rhs)
emit {
  MX64_MOV(lhs, i1)
  MX64_SUB(rhs, i1)
}
match MIR_SUB i1(Register reg, Immediate imm)
emit {
  MX64_SUB(imm, reg)
  MX64_MOV(reg, i1)
}
match MIR_SUB i1(Immediate imm, Register reg)
emit {
  MX64_MOV(imm, i1)
  MX64_SUB(reg, i1)
}

;;;; BITWISE

match MIR_AND i1(Immediate value, Immediate mask)
emit {
  MX64_MOV(value, i1)
  MX64_AND(mask, i1)
}
match MIR_AND i1(Immediate value, Register mask)
emit {
  MX64_MOV(value, i1)
  MX64_AND(mask, i1)
}
match MIR_AND i1(Register value, Register mask)
emit {
  MX64_AND(mask, value)
  MX64_MOV(value, i1)
}
match MIR_AND i1(Register value, Immediate mask)
emit {
  MX64_AND(mask, value)
  MX64_MOV(value, i1)
}

match MIR_OR i1(Immediate value, Immediate bits)
emit {
  MX64_MOV(value, i1)
  MX64_OR(bits, i1)
}
match MIR_OR i1(Immediate value, Register bits)
emit {
  MX64_MOV(value, i1)
  MX64_OR(bits, i1)
}
match MIR_OR i1(Register value, Register bits)
emit {
  MX64_OR(bits, value)
  MX64_MOV(value, i1)
}
match MIR_OR i1(Register value, Immediate bits)
emit {
  MX64_OR(bits, value)
  MX64_MOV(value, i1)
}

match MIR_SHL i1(Immediate value, Immediate shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_MOV(value, i1)
  MX64_SAL(i1)
}
match MIR_SHL i1(Register value, Register shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_SAL(value)
  MX64_MOV(value, i1)
}

match MIR_SHR i1(Immediate value, Immediate shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_MOV(value, i1)
  MX64_SHR(i1)
}
match MIR_SHR i1(Register value, Register shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_SHR(value)
  MX64_MOV(value, i1)
}

match MIR_SAR i1(Immediate value, Immediate shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_MOV(value, i1)
  MX64_SAR(i1)
}
match MIR_SAR i1(Register value, Register shift_amount)
emit {
  MX64_MOV(shift_amount, Register = ecx)
  MX64_SAR(value)
  MX64_MOV(value, i1)
}

;;;; COMPARISON
match
MIR_LT lt(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, lt)
  MX64_SETCC(Immediate cmp_type = COMPARE_LT, lt)
}
match
MIR_GT gt(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, gt)
  MX64_SETCC(Immediate cmp_type = COMPARE_GT, gt)
}
match
MIR_LE le(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, le)
  MX64_SETCC(Immediate cmp_type = COMPARE_LE, le)
}
match
MIR_GE ge(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, ge)
  MX64_SETCC(Immediate cmp_type = COMPARE_GE, ge)
}
match
MIR_EQ eq(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, eq)
  MX64_SETCC(Immediate cmp_type = COMPARE_GT, eq)
}
match
MIR_NE ne(Register lhs, Register rhs)
emit {
  MX64_CMP(lhs, rhs)
  ;; We MUST use mov here instead of xor as mov does not clobber flags.
  MX64_MOV(Immediate i = 0, ne)
  MX64_SETCC(Immediate cmp_type = COMPARE_NE, ne)
}

;;;; Alternative Syntax Experiments:

;;match MIR_ADD i1
;;  where i1 has Immediate lhs, Immediate rhs
;;emit
;;  MX64_MOV(rhs, REG i1)
;;  MX64_ADD(lhs, REG i1)
;;  .

;;match i1
;;  where i1 MIR_ADD
;;    with o1 IMM, o2 IMM
;;emit {
;;  MOV o1, i1 REG
;;  ADD o2, i1 REG
;;} .
